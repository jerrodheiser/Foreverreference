# This file should establish the different configurations you have for:
#   -Production
#   -Devlopment
#   -Testing
import os
basedir = os.path.abspath(os.path.dirname(__file__))    # sets dir to this one

# Its best to use this so you don't have to write down passwords anywhere
# Mail stuff must come before the instantiation of mail or else you will get
#   Errno 111 when the message is sending
# To configure os environemt variables ( in bash ):
#       export MAIL_USERNAME='username@gmail.com'
# These are ultimately referenced later using:
#  app.config[SECRET_KEY], which will return the subject string
# you can also update it after this by app.config.update(PARAM=VAL, P2=V2)
class Config:
    # Secret key protects the user session against tampering.
    # Required to be configured when using forms.
    # Simply generated by picking a hard to gues string.
    # Prevents against cross-site request forgery attacks (CSRF), which are essentially
    #   a malicious website sending requests for some purpose.
    # For added security store in an environment variable
    SECRET_KEY = os.environ.get("SECRET_KEY", 'backup if variable is empty') # Gets either
    APP_ADMIN = os.environ.get("APP_ADMIN","jheiser38@gmail.com")
    MAIL_SERVER = os.environ.get("MAIL_SERVER", 'smtp.googlemail.com') # using because gmail
    MAIL_PORT = int(os.environ.get('MAIL_PORT','587'))  # must use port 587 with TLS
    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS','true').lower() in \
        ['true','on','1']       # returns binary if in the list
    MAIL_USERNAME = 'jheiser38.b@gmail.com'# os.environ.get('MAIL_USERNAME', 'jheiser38.b@gmail.com')
    MAIL_PASSWORD = 'BillyWeiner69^(' #os.environ.get('MAIL_PASSWORD','BillyWeiner69^(')
    MAIL_PREFIX = os.environ.get('MAIL_PREFIX','App Name')
    MAIL_SENDER = 'Admin <jheiser38.b@gmail.com>' # This is just how it displays in the email
    SQLALCHEMY_TRACK_MODIFICATIONS = False      # Tracks changes to rows
    POST_PER_PAGE = 20
    COMMENT_PER_PAGE = 50
    FLASK_FOLLOWERS_PER_PAGE = 50
    DEBUG = True
    CHROME_DRIVER_URI = os.path.join(basedir,'venv/chromedriver')
    SQLALCHEMY_RECORD_QUERIES = True # This is normally disabled if not in DEBUG
                                    # mode, but is more useful in production.
    SLOW_DB_QUERY_TIME = 0.5
    SSL_REDIRECT = False
    # This is just kind of a placeholder right now
    @staticmethod
    def init_app(app):
        pass

# Invokes the debug option, and also creates a temporary database
class DevelopmentConfig(Config):
    DEBUGs = True
    # This is where the database file location is defined.
    # SQLAlchemy runs a local database, vice online.
    # the filepath is generated using the overall application directory filepath
    SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URL',
        'sqlite:///'+ os.path.join(basedir,'data-dev.sqlite'))

# Creates a testing database to maintain data
class TestingConfig(Config):
    TESTING = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('TEST_DATABASE_URL',
        'sqlite://')        # stored in memory because theres not need to keep it
    WTF_CSRF_ENABLED = False # all wtforms have this csrf, which is easier to
                            #   test if its disabled

# THis will eventually be used for production purposes
class ProductionConfig(Config):
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL',
        'sqlite:///'+ os.path.join(basedir,'data.sqlite'))
    SSL_REDIRECT = True

    # This is the error logger, which will send an email with the errors it
    #   encounters based on the main.after_app_request view function in main/views
    @classmethod
    def init_app(cls,app):
        Config.init_app(app)
        #email errors to the administrators
        import logging
        from logging.handlers import SMTPHandler
        credentials = None
        secure = None
        if getattr(cls,'MAIL_USERNAME',None) is not None:
            # getattr takes an object (cls), and searches in the object for the
            #   attribute (MAIL_USERNAME), which is a string for the purposes
            #   of python.  It will essentially return cls.MAIL_USERNAME or None
            #   if nothing is found.
            credentials = (cls.MAIL_USERNAME,cls.MAIL_PASSWORD)
            if getattr(cls,'MAIL_USE_TLS',None):
                secure()
        mail_handler = SMTPHandler(
            mailhost = (cls.MAIL_SERVER,cls.MAIL_PORT),
            fromaddr = cls.MAIL_SENDER,
            toaddrs = [cls.APP_ADMIN],
            subject = cls.MAIL_PREFIX + ' Application Error',
            credentials = credentials,
            secure = secure)
        mail_handler.setLevel(logging.ERROR) # This sets the mail handler level at
                                             # Error, which will send error data
                                             # in the emails
        app.logger.addHandler(mail_handler)


# This will allow for a new logging handler, which will
class HerokuConfig(ProductionConfig):
    SSL_REDIRECT = True if os.environ.get('DYNO') else False
    # heroku platform supports https, so it is enabled here
    # Heroku sets this variable in its environment, which will prevent it from
    #   sabotaging local testing

    @classmethod
    def init_app(cls,app):
        ProductionConfig.init_app(app)

        # Handle reverse proxy server headers
        # Reverse proxy servers handle all requests, and then send them to the
        #   associated app (how heroku handles things)
        # My code for user confirmation sends you right to an address, which
        #   won't jive with the reverse proxyness of heroku.
        # What this fix inspects requests when they come in, and modify them to work.
        from werkzeug.contrib.fixers import ProxyFix
        app.wsgi_app = ProxyFix(app.wsgi_app)

        # log to stderr
        import logging
        from logging import StreamHandler
        file_handler = StreamHandler()
        file_handler.setLevel(logging.INFO)
        app.logger.addHandler(file_handler)


# This is the configuration if using a traditional deployment
class UnixConfig(ProductionConfig):
    @classmethod
    def init_app(cls,app):
        ProductionConfig.init_app(app)

        # log to syslog
        import logging from logging.handlers import SysLogHandler
        syslog_handler = SysLogHandler()
        syslog_handler.setLevel(logging.WARNING)
        app.logger.addHandler(syslog_handler)

# Dictionary which is called in the parent function in __init__.py to return an
# object which will give all the configuration variables.
config = {
    'development':DevelopmentConfig(),
    'testing':TestingConfig(),
    'production':ProductionConfig(),
    'heroku':HerokuConfig(),

    'default':DevelopmentConfig()
}
